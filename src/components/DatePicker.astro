---
interface Props {
  label?: string;
  nameFrom?: string;
  nameTo?: string;
  minDate?: string;
  maxDate?: string;
  required?: boolean;
  helperText?: string;
  enableTime?: boolean;
  mode?: 'single' | 'range';
  name?: string;
  id?: string;
  defaultTime?: string;
}

const {
  label = "Select Date Range",
  nameFrom = "dateFrom",
  nameTo = "dateTo",
  minDate = "",
  maxDate = "",
  required = false,
  helperText = "",
  enableTime = false,
  mode = "range",
  name = "",
  id = "",
  defaultTime = "09:00"
} = Astro.props;

// Generate unique IDs for single mode
const pickerId = id || `flatpickr-${Math.random().toString(36).substr(2, 9)}`;
const isSingleMode = mode === 'single';
---

<div class="flex flex-col space-y-2 w-full datetime-picker-wrapper" data-picker-id={pickerId}>
  {label && (
    <label class="font-medium text-slate-700">
      {label}
      {required && <span class="text-red-500 ml-1">*</span>}
    </label>
  )}

  <input
    id={pickerId}
    type="text"
    class="border border-gray-300 px-4 py-2.5 rounded-lg w-full focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all"
    placeholder={isSingleMode ? "Pick a date" : "Pick a date range"}
    autocomplete="off"
    data-min={minDate}
    data-max={maxDate}
    data-enable-time={enableTime}
    data-mode={mode}
    data-default-time={defaultTime}
    required={required}
  />

  {isSingleMode ? (
    <input type="hidden" name={name} id={`${pickerId}-hidden`} />
  ) : (
    <>
      <input type="hidden" name={nameFrom} id={`${pickerId}-from`} />
      <input type="hidden" name={nameTo} id={`${pickerId}-to`} />
    </>
  )}

  <!-- Error message -->
  <div 
    id={`${pickerId}-error`}
    data-error={pickerId}
    class="hidden text-sm text-red-500 flex items-center gap-1"
  >
    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
    </svg>
    <span data-error-text={pickerId}></span>
  </div>

  {helperText && (
    <p class="text-xs text-slate-500">{helperText}</p>
  )}
</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css" />
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script is:inline define:vars={{ pickerId }}>
  document.addEventListener("DOMContentLoaded", () => {
    try {
      const picker = document.getElementById(pickerId);
      if (!picker) {
        console.warn(`DatePicker: Element #${pickerId} not found`);
        return;
      }

      const min = picker.dataset.min || null;
      const max = picker.dataset.max || null;
      const enableTime = picker.dataset.enableTime === "true";
      const mode = picker.dataset.mode || "range";
      const defaultTime = picker.dataset.defaultTime || "09:00";

      const formatter = new Intl.DateTimeFormat("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
        ...(enableTime && {
          hour: "2-digit",
          minute: "2-digit"
        })
      });

      const config = {
        mode: mode,
        dateFormat: enableTime ? "Y-m-d H:i" : "Y-m-d",
        enableTime: enableTime,
        time_24hr: false,
        minDate: min,
        maxDate: max,
        ...(enableTime && {
          defaultHour: parseInt(defaultTime.split(':')[0]),
          defaultMinute: parseInt(defaultTime.split(':')[1])
        }),
        // Disable mobile native picker for consistent behavior
        disableMobile: true,
        static: true,
        onReady: function(selectedDates, dateStr, instance) {
          // Guard: ensure calendarContainer exists (may not on mobile with native picker)
          if (!instance) return;
          try {
            if (instance.calendarContainer) {
              instance.calendarContainer.classList.add('flatpickr-enhanced');
            }
          } catch (e) {
            // Ignore DOM manipulation errors on mobile
          }
          
          // Set initial value if exists to prevent validation errors
          // Use local time format (Y-m-d H:i) to avoid timezone issues
          try {
            if (mode === 'single') {
              const hiddenInput = document.getElementById(`${pickerId}-hidden`);
              if (hiddenInput && selectedDates.length > 0) {
                const selected = selectedDates[0];
                // Store as local datetime (Y-m-d H:i) to avoid UTC conversion issues
                const localDate = new Date(selected.getTime() - selected.getTimezoneOffset() * 60000);
                if (enableTime) {
                  hiddenInput.value = localDate.toISOString().slice(0, 16);
                } else {
                  hiddenInput.value = localDate.toISOString().split("T")[0];
                }
              }
            } else {
              const inputFrom = document.getElementById(`${pickerId}-from`);
              const inputTo = document.getElementById(`${pickerId}-to`);
              if (inputFrom && inputTo && selectedDates.length > 0) {
                const start = selectedDates[0];
                const end = selectedDates.length === 2 ? selectedDates[1] : selectedDates[0];
                
                // Store as local datetime
                const startLocal = new Date(start.getTime() - start.getTimezoneOffset() * 60000);
                const endLocal = new Date(end.getTime() - end.getTimezoneOffset() * 60000);
                
                if (enableTime) {
                  inputFrom.value = startLocal.toISOString().slice(0, 16);
                  inputTo.value = endLocal.toISOString().slice(0, 16);
                } else {
                  inputFrom.value = startLocal.toISOString().split("T")[0];
                  inputTo.value = endLocal.toISOString().split("T")[0];
                }
              }
            }
          } catch (e) {
            console.warn(`DatePicker: Error setting initial value for ${pickerId}:`, e);
          }
        },
        onChange: function(selectedDates, dateStr, instance) {
          // Trigger validation on change
          const changeEvent = new Event('change', { bubbles: true });
          picker.dispatchEvent(changeEvent);
        },
        onClose: (dates, _, instance) => {
          if (!dates || dates.length === 0) return;

          try {
            if (mode === 'single') {
              const selected = dates[0];
              const hiddenInput = document.getElementById(`${pickerId}-hidden`);
              if (!hiddenInput) return;
              
              // Use local time to avoid timezone issues
              const localDate = new Date(selected.getTime() - selected.getTimezoneOffset() * 60000);
              if (enableTime) {
                hiddenInput.value = localDate.toISOString().slice(0, 16);
                if (instance && instance.input) instance.input.value = formatter.format(selected);
              } else {
                hiddenInput.value = localDate.toISOString().split("T")[0];
                if (instance && instance.input) instance.input.value = formatter.format(selected);
              }

              // Dispatch change event for validation
              const changeEvent = new Event('change', { bubbles: true });
              hiddenInput.dispatchEvent(changeEvent);

            } else {
              // Range mode
              const start = dates[0];
              const end = dates.length === 2 ? dates[1] : dates[0];

              const inputFrom = document.getElementById(`${pickerId}-from`);
              const inputTo = document.getElementById(`${pickerId}-to`);
              if (!inputFrom || !inputTo) return;

              // Use local time
              const startLocal = new Date(start.getTime() - start.getTimezoneOffset() * 60000);
              const endLocal = new Date(end.getTime() - end.getTimezoneOffset() * 60000);
              
              if (enableTime) {
                inputFrom.value = startLocal.toISOString().slice(0, 16);
                inputTo.value = endLocal.toISOString().slice(0, 16);
              } else {
                inputFrom.value = startLocal.toISOString().split("T")[0];
                inputTo.value = endLocal.toISOString().split("T")[0];
              }

              if (instance && instance.input) {
                instance.input.value = `${formatter.format(start)} - ${formatter.format(end)}`;
              }

              // Dispatch change events
              inputFrom.dispatchEvent(new Event('change', { bubbles: true }));
              inputTo.dispatchEvent(new Event('change', { bubbles: true }));
            }
          } catch (e) {
            console.warn(`DatePicker: Error in onClose for ${pickerId}:`, e);
          }
        },
      };

      const fpInstance = flatpickr(`#${pickerId}`, config);

      // Guard: ensure instance was created
      if (!fpInstance) {
        console.warn(`DatePicker: Failed to initialize flatpickr for #${pickerId}`);
        return;
      }

      // Store instance for external access
      picker._flatpickr = fpInstance;

      // Expose methods to update constraints
      window.updateDatePickerConstraints = window.updateDatePickerConstraints || {};
      window.updateDatePickerConstraints[pickerId] = {
        setMinDate: (date) => {
          try {
            if (fpInstance && typeof fpInstance.set === 'function') {
              fpInstance.set('minDate', date);
            }
          } catch (e) {
            console.warn(`DatePicker: Error setting minDate for ${pickerId}:`, e);
          }
        },
        setMaxDate: (date) => {
          try {
            if (fpInstance && typeof fpInstance.set === 'function') {
              fpInstance.set('maxDate', date);
            }
          } catch (e) {
            console.warn(`DatePicker: error setting maxDate for ${pickerId}:`, e);
          }
        },
        getInstance: () => fpInstance
      };
    } catch (error) {
      console.error(`DatePicker: Fatal error initializing #${pickerId}:`, error);
    }
  });
</script>

<style is:global>
  .flatpickr-enhanced {
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    border-radius: 12px;
    border: 1px solid #e2e8f0;
  }

  .flatpickr-enhanced .flatpickr-day.selected,
  .flatpickr-enhanced .flatpickr-day.selected:hover {
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    border-color: #3b82f6;
  }

  .flatpickr-enhanced .flatpickr-day.inRange {
    background: #dbeafe;
    border-color: #93c5fd;
    box-shadow: none;
  }

  .flatpickr-enhanced .flatpickr-day:hover {
    background: #f1f5f9;
  }

  .flatpickr-enhanced .flatpickr-current-month .flatpickr-monthDropdown-months {
    background: white;
  }

  .flatpickr-enhanced .flatpickr-current-month .flatpickr-monthDropdown-months:hover {
    background: #f1f5f9;
  }

  .flatpickr-calendar.arrowTop:before,
  .flatpickr-calendar.arrowTop:after {
    display: none;
  }

  /* Disabled dates styling */
  .flatpickr-day.flatpickr-disabled {
    color: #cbd5e1;
    cursor: not-allowed;
  }

  .flatpickr-day.flatpickr-disabled:hover {
    background: transparent;
    border-color: transparent;
  }

  /* Time input styling */
  .flatpickr-time input {
    font-weight: 500;
  }

  .flatpickr-time input:hover,
  .flatpickr-time input:focus {
    background: #f1f5f9;
  }
</style>